import numpy as np

from .candidate_generator import CandidateGenerator
from .language_model import LanguageModel


class CandidateScorer:
    """Combines the `LanguageModel`, `EditProbabilityModel`, and
    `CandidateGenerator` to produce the most likely query Q given a raw query R.
    Since the candidate generator already uses the edit probability model, we
    do not need to take the edit probability model as an argument in the constructor.
    """

    def __init__(self, lm: LanguageModel, cg: CandidateGenerator, mu: float = 1.0):
        """
        Args:
            lm (LanguageModel): Language model for estimating P(Q).
            cg (CandidateGenerator): Candidate generator for generating possible Q.
            mu (float): Weighting factor for the language model (see write-up).
                Remember that our probability computations are done in log-space.
        """
        self.lm = lm
        self.cg = cg
        self.mu = mu

    def get_score(self, query: str, log_edit_prob: float) -> float:
        """Computes the final score for a candidate using bayes theorem.

        P(Q|R) ~ P(R|Q) * P(Q)^mu, or in logs
        log(P(Q|R)) ~ Log(P(R|Q)) + mu * Log(P(Q))

        score for a candidate `query`. Uses `mu` as weighting exponent for P(Q).
        """

        return log_edit_prob + self.mu * self.lm.get_query_logp(query)

    def correct_spelling(self, raw: str):
        """Corrects spelling of raw query `r` to get the intended query `q`.

        Args:
            r (str): Raw input query from the user.

        Returns:
            q (str): Spell-corrected query. That is, the query that maximizes
                P(R|Q)*P(Q) under the language model and edit probability model,
                restricted to Q's generated by the candidate generator.
        """
        
        candidates = list(self.cg.get_candidates(raw))
        score = [self.get_score(query, log_edit_prob) for query, log_edit_prob in candidates]
        return candidates[np.argmax(score)][0] # Get the query with max score
